#! /bin/sh

yast="$1"
shift

exec 2>&1
stty sane

echo -en \\033c

# linuxrc passes the root directory of the freshly mounted instsys in
# the environment variable INSTSYS.
#

# this script will symlink from the initrd to all files and
# directories missing.

# a few files should be restored when installation has completed if we
# return to linuxrc.
FILES_TO_RESTORE="/etc/ld.so.cache"
for file in $FILES_TO_RESTORE
do
    test -e $file && mv $file $file.initrd
done


echo "integrating the installation system into the ramdisk..."
$INSTSYS/usr/bin/conservative_lndir "$INSTSYS" "/"

echo "integrating the shared objects of the installation system..."
ldconfig

if test -x /sbin/syslogd
then
    checkproc /sbin/syslogd || {
	echo "starting syslog (messages are logged to /dev/tty4)..."
	/sbin/syslogd
    }
fi

arch=$(uname -m)

case "$arch" in
  i?86)
    # remove modules to free memory
    rm -f /modules/*
    touch /modules/{MORE,NEEDMOD} etc/need_modules_disk
  ;;
esac

# create a new modules.dep
#
# modules from initrd (in /modules) are preferred over those from CD (below
# /lib/modules)
#
rm -f /etc/modules.conf
cp "$INSTSYS/etc/modules.conf" /etc
cat >>/etc/modules.conf <<EOF
path=/modules
path=/lib/modules/`uname -r`
depfile=/etc/modules.dep
generic_stringfile=/etc/modules.generic_string
pcimapfile=/etc/modules.pcimap
isapnpmapfile=/etc/modules.isapnpmap
usbmapfile=/etc/modules.usbmap
parportmapfile=/etc/modules.parportmap
EOF

echo "integrating kernel modules of the installation system..."
depmod -a 2>/dev/null

# eventually start sshd
case "$arch" in
    s390|s390x)
	test -r /etc/netsetup.inf && cat /etc/netsetup.inf >> /etc/install.inf
	;;
    *)
	if [ -x /usr/sbin/sshd ] && \
          grep -vq ' nossh' /proc/cmdline && \
          grep -q 'Bootmode:.*Net' /etc/install.inf ; then
	    SSH_FAILED=
	    echo 'sshd found, prepare remote login'
	    rm -rf /etc/ssh /root /etc/shadow
	    mkdir -p /root/.ssh
	    cp -a $INSTSYS/root/.ssh/* /root/.ssh
	    cp -a $INSTSYS/root/.bash_login /root
	    cp -a $INSTSYS/root/.vimrc /root
	    cp -a $INSTSYS/etc/shadow /etc
	    cp -a $INSTSYS/etc/ssh /etc
            chmod -R og-rxw  /etc/ssh /root /etc/shadow 2>/dev/null
	    chown -R 0.0  /etc/ssh /root /etc/shadow 2>/dev/null
	    # echo "nameserver 10.10.0.1" > /etc/resolv.conf
	    # echo "nameserver 10.10.11.1" >> /etc/resolv.conf
	    # echo "search suse.de" >> /etc/resolv.conf
	    mkdir -p /dev/pts
	    mkdir -p /dev/shm
	    grep -q devpts /proc/mounts || \
                mount -n -t devpts -o mode=0620,gid=5 devpts /dev/pts
	    /usr/sbin/sshd || {
	        export SSH_FAILED=true
	        echo 'sshd did NOT start!'
	    }
	    if [ ! "$SSH_FAILED" ] ; then
	        echo
	        echo /sbin/ifconfig `grep eth /proc/net/dev | cut -f 1 -d : `
	        for i in  `grep eth /proc/net/dev | cut -f 1 -d : ` ; do
		    /sbin/ifconfig $i | grep UP > /dev/null 2>&1 && /sbin/ifconfig $i | head -n 2
	        done
                cat <<EOF

      ***  sshd has been started  ***

  This is only done during beta tests.
  It is NOT a feature of the final release.

  If you don't want sshd to be started, use
  the 'nosshd' option at the boot prompt.

  Press return to contiunue...
EOF
	        read
	    fi
	    export Y2DEBUG=1
        fi
        ;;
esac


# yast1 doesn't like it
rm -f /etc/fstab

# now, run yast
echo "starting yast..."
ec=
if [ "$yast" = yast1 ] ; then
    /sbin/yast "$@" ; ec=$?
fi

if [ "$yast" = yast2 ] ; then
    /usr/lib/YaST2/bin/YaST2.start "$@" ; ec=$?
fi

# stop sshd
killall sshd 2>/dev/null >/dev/null

umount devpts 2>/dev/null

for file in $FILES_TO_RESTORE
do
    test -e $file.initrd && mv $file.initrd $file
done


exit $ec
