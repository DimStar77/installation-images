#! /usr/bin/perl

#
# !!! sorry, doc is outdated !!!
#

# Create a boot disk and put everything on it.
#
# Source files and the file list are taken from data/boot; the image is
# stored in images/boot.
#
# The maximum possible initrd size is returned in tmp/boot.max_initrd_size.
#
# Usage:        mk_boot

=head1 mk_boot

C<mk_boot> creates a boot disk.

It packs the files from C<data/boot/boot.file_list> into a 1.44M FAT image
and stores the image file as C<images/boot>.

It needs C<syslinux> to do it. The location of the C<syslinux> binary is
given in the C<syslinux> entry in C<etc/config>. Normally something like

C<syslinux=../syslinux/syslinux>

(if you are within the CVS tree).

In addition to making a boot image, C<mk_boot> writes the maximum allowed
size for C<initrd> to C<tmp/boot.max_initrd_size>. This is intended to be
potentially useful for the C<mk_initrd> script (but currently this info
isn't used).

C<mk_boot> creates a FAT file system with only one FAT and with 15 root directory
entries. This saves 11 kbytes on a 1.44M floppy.

Note: if by any chance your C<initrd> is just too big by a few
I<bytes>, you can try varying the cluster size. It I<may> help.

=cut


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# the usual fuss...

BEGIN { unshift @INC, ( $0 =~ /(.*?)((?<![^\/])bin\/)?[^\/]+$/ )[0] . "lib" }
use ReadConfig;
use AddFiles;
use MakeFATImage;

sub opt_initrd;

die "usage: $Script\n" if @ARGV;


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# some config data

$srcdir = "${DataPath}boot";
$tmpdir = "${BasePath}tmp";
$image = "${ImagePath}boot";
$initrddir = "$tmpdir/initrd";
$initrddirx = "$tmpdir/.initrd";
$initdisk = "${ImagePath}initrd";

$arch = $ConfigData{suse_arch};
$fstype = $arch eq 'i386' ? 'msdos' : 'vfat';

if($arch eq 'i386') {
  $syslx = "$BasePath$ConfigData{syslinux}";
  die "$Script: where is syslinux?" unless $ConfigData{syslinux} && -x $syslx;
}

#$kernel = "$BasePath$ConfigData{kernel}";
#die "$Script: which kernel do we use?" unless $ConfigData{kernel} && -f $kernel;

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# now we really start...

# clean up
if(-d $initrddirx) {
  die "$Script: the initrd must be rebuilt";
}

$i1 = $ConfigData{suse_major_release};
$i2 = $ConfigData{suse_minor_release};

$label = "SUSE${i1}${i2}_BOOT";

# create an empty image
if($ENV{'boot'} eq 'small') {
  ($blocks, $block_size) = MakeFATImage($image, $label, 1)
}
elsif($ENV{'boot'} eq 'large' || ($arch eq 'ia64' && !$ENV{'boot'})) {
  # about 20MB image; see lib/MakeFATImage.pm for the meaning of the args
  ($blocks, $block_size) = MakeFATImage($image, $label, 2, 63, 16, 40)
}
else {
  ($blocks, $block_size) = MakeFATImage($image, $label, 2, 36)
}

die "$Script: failed to create FAT disk image \"$image\"\n" unless defined $blocks;

printf "$Script: image \"%s\", %u blocks a %u bytes (%u total)\n", $image, $blocks, $block_size, $blocks * $block_size;

# make it bootable and add syslinux
if($arch eq 'i386') {
  $xx = "-s" if $ENV{'boot'} eq 'small';
  SUSystem "$syslx $xx $image" and
    die "$Script: syslinux failed";
}

# umount it first, just in case
SUSystem "umount /mnt 2>/dev/null";

# add the other files
SUSystem "mount -oloop -t $fstype $image /mnt" and
  die "$Script: mount failed";

# copy everything *except* the initdisk
AddFiles "/mnt", "${srcdir}/boot.file_list", $srcdir or
  die "$Script: failed to setup boot image";

if($arch eq 'i386') {
  system "cp /mnt/message $TmpBase.boot";
  system "perl -pi -e 's/x\\.y/$ENV{suse_release}/g' $TmpBase.boot";
  SUSystem "cp $TmpBase.boot /mnt/message";
  unlink "$TmpBase.boot";

  SUSystem "umount /mnt" and
    die "$Script: umount failed";

  Print2File $MToolsCfg, "drive r: file=\"$image\"\n" or die "$Script: oops!";
  @f = `mdir r:`;
  unlink $MToolsCfg;

  for (@f) {
    if(/^\s*([ 0-9]+?)\s+bytes\s+free\s*$/) {
      $free = $1;
      $free =~ s/\s+//g;
      last;
    }
  }

  die "$Script: oops, no space on boot disk???" unless defined $free;

  print "$Script: prepared boot disk \"$image\"; $free bytes for initrd\n";

  # Print2File "$tmpdir/initrd.max_size", "$free\n" or die "$Script: oops!";

  $j = -s $initdisk;
  die "$Script: $initdisk missing" unless $j > 0;
  $k = $j - $free;
  if($k >= 0) {
    print "$Script: $initdisk $k bytes too big\n";
    opt_initrd $free;
    $j = -s $initdisk;
    $k = $j - $free
  }
  die "$Script: $initdisk $k bytes too big! ($j)\n" unless $j < $free;
  $xfree = $free - $j;

  # add the initdisk
  SUSystem "mount -oloop -t $fstype $image /mnt" and
    die "$Script: mount failed";
}

# copy the initdisk
SUSystem "cp $initdisk /mnt/initrd" and
  die "$Script: could not add $initdisk to the image";

$i3 = $i2*10;
SUSystem "touch -d $i1:$i3 /mnt/*";

print "contents of $image:\n";
system "ls -l /mnt";

SUSystem "umount /mnt" and
  die "$Script: umount failed";

print "$Script: finished boot disk \"$image\"";
print defined($xfree) ? "; $xfree bytes free\n" : "\n";

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# remove files from initrd until it fits to the disk
#
sub opt_initrd
{
  my ($isize, $maxsize, @mlist, %mlist, @mods, %mods, $i, $j, $m);
  my (@dl, @al, @xl, $rb);
  local ($_);

  $maxsize = shift;
  $isize = -s $initdisk;
  die "$Script: failed to create $initrddirx ($!)" unless mkdir $initrddirx, 0777;
  $ENV{'keep_initrd'} = 'yes';
  open M, "$tmpdir/initrd.opt_mods"; @mlist = <M>; close M;
  chop @mlist;
  $j = 0;
  for (@mlist) {
    $i = $_;
    $i =~ s/.*\///;
    push @mods, $i;
    $mlist{$_} = $j;
    $mods{$i} = $j;
    $j++;
  }

  for (reverse @mlist) {
    $m = $mods[$mlist{$_}];
    die "$Script: oops" if $m eq "";
    unshift @dl, $_;
    $j = -s "$initrddir/$_";
    print "$Script: dropping $_ ($j bytes)\n";
    SUSystem "mv $initrddir/$_ $initrddirx/$m";
    system "bin/mk_initrd";
    $isize = -s $initdisk;
    die "$Script: $initdisk missing" unless $isize > 0;
    if($isize >= $maxsize) {
      $i = $isize - $maxsize;
      print "$Script: initrd still $i bytes too big\n";
    }
    else {
      last
    }
  }

  if($isize < $maxsize) {
    @al = @dl;
    shift @al;
    # see if we can add some mods
    for (@al) {
      $m = $mods[$mlist{$_}];
      die "$Script: oops" if $m eq "";
      $j = -s "$initrddirx/$m";
      print "$Script: trying to re-add $_ ($j bytes)\n";
      SUSystem "mv $initrddirx/$m $initrddir/$_";
      system "bin/mk_initrd";
      $isize = -s $initdisk;
      die "$Script: $initdisk missing" unless $isize > 0;
      $rb = 0;
      if($isize >= $maxsize) {
        print "$Script: well, that was too much\n";
        SUSystem "mv $initrddir/$_ $initrddirx/$m";
        $rb = 1;
      }
      else {
        $j = $maxsize - $isize;
        print "$Script: yup, that worked ($j bytes left)\n";
      }
    }
    if($rb) {
      system "bin/mk_initrd";
      $isize = -s $initdisk;
      die "$Script: $initdisk missing" unless $isize > 0;
    }
  }

  for (@dl) {
    $m = $mods[$mlist{$_}];
    die "$Script: oops" if $m eq "";
    if(-f "$initrddirx/$m") {
      SUSystem "mv $initrddirx/$m $initrddir/$_";
      push @xl, $_;
    }
  }
  die "$Script: failed to remove $initrddirx ($!)" unless rmdir $initrddirx;

  if(@xl) {
    print "$Script: modules dropped:\n";
    for (@xl) {
      $j = -s "$initrddir/$_";
      print "  $_ ($j bytes)\n"
    }
  }
}

