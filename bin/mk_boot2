#! /usr/bin/perl -w

# Create a boot disk and put everything on it.
#
# Source files and the file list are taken from data/boot; the image is
# stored in images/boot.
#
# The maximum possible initrd size is returned in tmp/boot.max_initrd_size.
#
# Usage:        mk_boot

=head1 mk_boot

C<mk_boot> creates a boot disk.

It packs the files from C<data/boot/boot.file_list> into a 1.44M FAT image
and stores the image file as C<images/boot>.

It needs C<syslinux> to do it. The location of the C<syslinux> binary is
given in the C<syslinux> entry in C<etc/config>. Normally something like

C<syslinux=../syslinux/syslinux>

(if you are within the CVS tree).

In addition to making a boot image, C<mk_boot> writes the maximum allowed
size for C<initrd> to C<tmp/boot.max_initrd_size>. This is intended to be
potentially useful for the C<mk_initrd> script (but currently this info
isn't used).

C<mk_boot> creates a FAT file system with only one FAT and with 15 root directory
entries. This saves 11 kbytes on a 1.44M floppy.

Note: if by any chance your C<initrd> is just too big by a few
I<bytes>, you can try varying the cluster size. It I<may> help.

=cut


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# the usual fuss...

BEGIN { unshift @INC, ( $0 =~ /(.*?)((?<![^\/])bin\/)?[^\/]+$/ )[0] . "lib" }
use ReadConfig;
use AddFiles;
use MakeFATImage;

die "usage: $Script\n" if @ARGV;


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# some config data

$srcdir = "${DataPath}boot";
$tmpdir = "${BasePath}tmp";
$image = "${ImagePath}boot2";
$initdisk = "${ImagePath}initrd2";

$syslx = "$BasePath$ConfigData{syslinux}";
die "$Script: where is syslinux?" unless $ConfigData{syslinux} && -x $syslx;

#$kernel = "$BasePath$ConfigData{kernel}";
#die "$Script: which kernel do we use?" unless $ConfigData{kernel} && -f $kernel;

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# now we really start...

$i1 = $ConfigData{SuSE_major_release};
$i2 = $ConfigData{SuSE_minor_release};

$label = "SUSE${i1}${i2}_BOOT";

# create an empty image
($blocks, $block_size) = MakeFATImage($image, $label, 2, 36);

die "$Script: failed to create DOS disk image \"$image\"\n" unless defined $blocks;

printf "$Script: image \"%s\", %u blocks a %u bytes (%u total)\n", $image, $blocks, $block_size, $blocks * $block_size;

# make it bootable and add syslinux
$xx = $ENV{'demo'} eq 'yes' ? '-s' : '';
SUSystem "$syslx $xx $image" and
  die "$Script: syslinux failed";

# umount it first, just in case
SUSystem "umount /mnt 2>/dev/null";

# add the other files
SUSystem "mount -oloop -t msdos $image /mnt" and
  die "$Script: mount failed";

# copy everything *except* the initdisk
AddFiles "/mnt", "${srcdir}/boot.file_list", $srcdir or
  die "$Script: failed to setup boot image";

# add info
#if(!$ConfigData{in_abuild}) {
#  SUSystem "cp ${CfgPath}info /mnt" and
#    die "$Script: failed to copy info";
#}

#SUSystem "cp $kernel /mnt/linux" and
#  die "$Script: could not add the kernel image";

SUSystem "umount /mnt" and
  die "$Script: umount failed";

Print2File $MToolsCfg, "drive r: file=\"$image\"\n" or die "$Script: oops!";
@f = `mdir r:`;
unlink $MToolsCfg;

for (@f) {
  if(/^\s*([ 0-9]+?)\s+bytes\s+free\s*$/) {
    $free = $1;
    $free =~ s/\s+//g;
    last;
  }
}

die "$Script: oops, no space on boot disk???" unless defined $free;

print "$Script: prepared boot disk \"$image\"; $free bytes for initrd\n";

Print2File "$tmpdir/boot.max_initrd_size", "$free\n" or die "$Script: oops!";


$j = -s $initdisk;
die "$Script: $initdisk too big! ($j)" unless $j && $j <= $free;
$xfree = $free - $j;

# add the initdisk
SUSystem "mount -oloop -t msdos $image /mnt" and
  die "$Script: mount failed";

# copy the initdisk
SUSystem "cp $initdisk /mnt/initrd" and
  die "$Script: could not add $initdisk to the image";

$i3 = $i2*10;
SUSystem "touch -d $i1:$i3 /mnt/*";

print "contents of $image:\n";
system "ls -l /mnt";

SUSystem "umount /mnt" and
  die "$Script: umount failed";

print "$Script: finished boot disk \"$image\"; $xfree bytes free\n";

